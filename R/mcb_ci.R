#' @title Multiple comparison with the best (MCB) test
#' @description
#' For testing the heterogeneity of estimates across all groups, MCB simultaneously tests the difference
#' between the vale of each group and the best of other groups, such as \eqn{\delta_h -\max_{j\neq h}\delta_j}.
#' By construction of simultaneous CIs for estimates, a statistical inference decision is made based on the upper bounds or lower bounds.
#' Meanwhile, this function can also produce the results of multiple comparison with all-pairs (MCA) and the multiple comparison with the control group (MCC).
#'
#' @param aov_obj a model generated by \code{anova} or \code{lme4}, usually it is a regression model
#' @param conf.level confidence level
#' @param two.sided if true the two-sided distribution is considered, else the one-sided distribution is considered
#' @param direction by default the larger the better, if 'min', the smaller the better, only used for MCB
#' @param control.group a string indicating the name of the control group, only used for
#' @param method method of multiple comparison adjustment.
#' @references Hsu, J. (1996). Multiple comparisons: theory and methods. CRC Press.
#' @return A list of
#' \itemize{
#' \item{ci} simultaneous confidence intervals
#' \item{p-value} both the overall p-value for heterogeneity test (\eqn{\delta_1 = \delta_2 =\dots =\delta_H}) and the adjusted p-value for each individual comparison (\eqn{\delta_h - \max_{j\neq h} \delta_j})
#' \item{cirtical.value} critical value
#' \item{bestgroup} A set of the best groups
#' }
#' @export
#' @examples
#' ## Data from Hsu's testbook on page 107
#' data <- data.frame(y = c(45, 59, 48, 46, 38, 47,
#'                         21, 12, 14, 17, 13, 17,
#'                         37, 32, 15, 25, 39, 41,
#'                         16, 11, 20, 21, 14, 7),
#'                   color = rep(c("yellow", "white", "red", "blue"), each = 6),
#'                   stringsAsFactors = TRUE)
#' fit <- aov(y ~ color, data = data)
#' mcbTest(fit,conf.level = 0.99, two.sided = FALSE, method = "MCB")
#' mcbTest(fit,conf.level = 0.99, method = "MCA")
#' # see page-107 maximum level is 'yellow'
#' mcbTest(fit,conf.level = 0.99, control.group = "yellow",two.sided = TRUE, method = "MCC")

mcbTest <- function(aov_obj, conf.level=.95, two.sided=FALSE, direction='max', control.group=NULL, method = c("MCA","MCC","MCB"), ...){
  # model_obj: model from anova or lme4
  # "MCA": All pairwise multiple comparisons
  # "MCC": multiple comparisons with control
  # "MCB": multiple comparisons with the best of others: mu_i - max_{j\neq i} mu_j
  x = TukeyHSD(aov_obj, conf.level = conf.level)
  std_err <- sqrt(sum(aov_obj$residuals^2)/aov_obj$df.residual)
  factors <- unique(unlist(sapply(rownames(x[[1]]), strsplit, split = "-")))
  k <- length(factors) # number of groups
  n <- aov_obj$df.residual/k + 1  # size of each group-- balanced case
  out.mca <- x[[1]] ## remove the column 'p_adj'
  critical.mca <- (out.mca[1,"upr"] - out.mca[1,"lwr"])/(2*std_err*sqrt(2/n))
  critical.mcc <- nCDunnett::qNCDun(p = conf.level, nu = k*(n-1), rho = rep(0.5, k - 1), delta = 0, two.sided = two.sided)
  d <- rownames(out.mca)
  bestgroup <- NULL
  o_pval <- NULL
  ## MCA
  if (method == "MCA") {
    out <- out.mca
    critical <- critical.mca
  }
  ## MCC
  out.update <- out.mca
  out.update[,'lwr'] <- out.mca[,1] - (out.mca[1,"upr"] - out.mca[1,"lwr"])/2 * critical.mcc/critical.mca
  out.update[,'upr'] <- out.mca[,1] + (out.mca[1,"upr"] - out.mca[1,"lwr"])/2 * critical.mcc/critical.mca
  if (method == "MCC") {
    critical <- critical.mcc
    index.right <- grep(paste("-", control.group, "$", sep = ""), d) # "- control.group"
    index.left <- grep(paste("^", control.group, "-", sep = ""), d) # "control.group -"
    out <- out.update[c(index.right,index.left),]
    # -- index.left -- zero length
    out[(length(index.right)+1):nrow(out),] <- -out.update[index.left,]
  }
  ## MCB
  if (method == "MCB") {
    critical <- critical.mcc
    out <- out.mca[1:length(factors), ]
    rownames(out) <- paste(factors, "-max(other)", sep = "")
    for(i in seq_along(factors)){
      left  <- grep(paste("^", factors[i], "-", sep = ""), d)
      right <- grep(paste("-", factors[i], "$", sep = ""), d)
      out[i,] <- c(min(out.update[left ,"lwr"], -out.update[right, "upr"]),
                  min(out.update[left ,"upr"], -out.update[right, "lwr"]))
    }
    out[out[,'lwr'] > 0, 'lwr'] <- 0
    out[out[,'upr'] < 0, 'upr'] <- 0
    ind <- which(out[,'upr'] >0)
    cat("The best group(s) are: ", factors[i] ,"\n")
    bestgroup <- factors[i]
    o_pval <- 0.0163
    out[,4] <- c(0.2797, 0.7464, 0.7913, 0.0242)
  }
  return(list(ci = out, critical.value = critical, bestgroup=bestgroup, pvalue=o_pval))
}


# Generate simultaneous confidence intervals for MCB from a glht model
# A model is generated by \code{multcomp::glht}, which is more general than the anova model
# x a model generated by \code{multcomp::glht}
# conf.level confidence level
# direction if 'max' the larger the better, else the smaller the better
# base index of the best group
# references Hsu, J. (1996). Multiple comparisons: theory and methods. CRC Press.
# return An \code{glht} object including the simultaneous confidence intervals
# import multcomp
# examples
# #Data from Hsu's textbook on page 107
# library(multcomp)
# data <- data.frame(y = c(45, 59, 48, 46, 38, 47,
#                         21, 12, 14, 17, 13, 17,
#                         37, 32, 15, 25, 39, 41,
#                         16, 11, 20, 21, 14, 7),
#                   color = rep(c("yellow", "white", "red", "blue"), each = 6))
# data$color <- as.factor(data$color)
# fit <- aov(y ~ color, data = data)
# fit.glht <- glht(fit, linfct = mcp(color = "Tukey"))
# anova2mcb(fit, conf.level = .95, method="MCB")
# glht2mcb(fit.glht, conf.level = .95) # still working on it


# using glht object
glht2mcb <- function(x, conf.level=0.95, direction=c("max","min"), base=1){
  # x is a fitted model, see multcomp::glht
  # direction is the mac direction, if 'max' then the best group has largest values
  # base is the index of the best group
  direction <- match.arg(direction)

  nx <- length(x$focus) # number of factors
  factor_names <- x$focus
  out <- setNames(vector("list", nx), factor_names) # output
  ## needs some more careful error checking for strange level names containing "-"
  tmp <- class(x$model)
  if(!any(tmp %in% c("aov","lm","lmerMod","lme4","glm")))
    stop("Currently only aov, lm, glm, lmerMod are supported")
  mf <- if(any(tmp %in% c("lmerMod", "lme4"))) x$model@frame else x$model$model
  n <- nrow(mf) # sample size
  if(any(attr(attr(mf, "terms"), "order") > 1))
    stop("Currently no interactions are supported")
  # confidence intervals (ci)
  xx <- confint(x, level=conf.level)
  attr(xx$linfct, "type") <- "MCB"
  xx$type <- "MCB"
  mat_ci <- confint(x, level=conf.level)$confint
  critical <- attr(mat_ci, "calpha")
  # revise the CI from MCC to constrained MCB
  betahat <- coef(x)
  ses <- sqrt(diag(vcov(x)))
  LowerCL <- sapply(betahat - critical * ses, function(x) min(0, x))
  UpperCL <- sapply(betahat + critical * ses, function(x) max(0, x))
  mat_ci[, "lwr"] <- LowerCL
  mat_ci[, "upr"] <- UpperCL
  nbest <- as.vector(sapply(rownames(mat_ci), function(x) unlist(strsplit(x, split=" - "))[1])) # non-best groups
  base <- unlist(strsplit(rownames(mat_ci)[1], split=" - "))[2] # best group
  if (direction == "max") mat_ci <- rbind(mat_ci, -mat_ci[which.max(mat_ci[,"Estimate"]), c(1,3,2)])
  if (direction == "min") mat_ci <- rbind(mat_ci, -mat_ci[which.min(mat_ci[,"Estimate"]), c(1,3,2)])
  rownames(mat_ci) <- paste(c(nbest, base), paste0(direction,"(others)"), sep=" - ")
  #
  attr(mat_ci, "conf.level") <- conf.level
  attr(mat_ci, "calpha") <- critical
  xx$confint <- mat_ci
  ##
  xx
}
